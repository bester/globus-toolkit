#include "globus_xio_load.h"
#include "globus_i_xio.h"

#define GLOBUS_L_XIO_DRIVER_TABLE_SIZE 16

extern globus_xio_driver_hook_t         @XIO_BUILTIN_HOOKS_DEC@;

static globus_xio_driver_hook_t *       builtins[] = 
{
    @XIO_BUILTIN_HOOKS_DEF@, GLOBUS_NULL
};

static globus_hashtable_t               globus_l_xio_load_drivers;
static globus_rmutex_t                  globus_l_xio_load_lock;

int
globus_i_xio_load_init(void)
{
    globus_xio_driver_hook_t **         builtin;
    GlobusXIOName(globus_i_xio_load_init);
    
    GlobusXIODebugInternalEnter();
    
    globus_rmutex_init(&globus_l_xio_load_lock, GLOBUS_NULL);
    
    if(globus_hashtable_init(
        &globus_l_xio_load_drivers,
        GLOBUS_L_XIO_DRIVER_TABLE_SIZE,
        globus_hashtable_string_hash,
        globus_hashtable_string_keyeq) != GLOBUS_SUCCESS)
    {
        return -1;
    }
    
    builtin = builtins;
    while(*builtin)
    {
        globus_hashtable_insert(
            &globus_l_xio_load_drivers, 
            (void *) (*builtin)->name, 
            *builtin);
            
        builtin++;
    }
    
    GlobusXIODebugInternalExit();
    return GLOBUS_SUCCESS;
}

static
void
globus_l_xio_load_destroy_cb(
    void *                              arg)
{
    globus_xio_driver_hook_t *          hook;
    
    hook = (globus_xio_driver_hook_t *) arg;
   
    globus_assert(hook->ref_count == 0);
}

int
globus_i_xio_load_destroy(void)
{
    GlobusXIOName(globus_i_xio_load_destroy);
    
    GlobusXIODebugInternalEnter();
    
    globus_rmutex_destroy(&globus_l_xio_load_lock);
    globus_hashtable_destroy_all(
        &globus_l_xio_load_drivers, globus_l_xio_load_destroy_cb);

    GlobusXIODebugInternalExit();
    
    return GLOBUS_SUCCESS;
}

globus_result_t
globus_xio_driver_load(
    const char *                        driver_name,
    globus_xio_driver_t *               out_driver,
    ...)
{
    globus_xio_driver_hook_t *          hook;
    globus_result_t                     result;
    va_list                             ap;
    GlobusXIOName(globus_xio_driver_load);
    
    GlobusXIODebugEnter();
    
    result = GLOBUS_SUCCESS;
    globus_rmutex_lock(&globus_l_xio_load_lock);
    {
        hook = (globus_xio_driver_hook_t *) globus_hashtable_lookup(
            &globus_l_xio_load_drivers, 
            (void *) driver_name);
    
        if(!hook)
        {
            /* not a builtin or not loaded yet... here is where I would do the 
             * dll stuff
             */
            
            result = GlobusXIOErrorInvalidDriver("Could not find driver");
            if(result != GLOBUS_SUCCESS)
            {
                goto error_find;
            }
        }
        else
        {
            if(hook->ref_count++ == 0)
            {
                if(globus_module_activate(hook->module) != GLOBUS_SUCCESS)
                {
                    hook->ref_count--;
                    result = GlobusXIOErrorInvalidDriver("Deactivate failed");
                    goto error_activate;
                }
            }
        }
        
        globus_module_activate(GLOBUS_XIO_MODULE);
        va_start(ap, out_driver);
        result = hook->load(out_driver, ap);
        va_end(ap);
    
        if(result != GLOBUS_SUCCESS)
        {
            result = GlobusXIOErrorWrapFailed(
                "globus_xio_driver_init_t", result);
            goto error_init;
        }
    }
    globus_rmutex_unlock(&globus_l_xio_load_lock);
    
    GlobusXIODebugExit();
    return GLOBUS_SUCCESS;

error_init:
    if(--hook->ref_count == 0)
    {
        globus_module_deactivate(hook->module);
    }
    globus_module_deactivate(GLOBUS_XIO_MODULE);
    
error_activate:
error_find:
    globus_rmutex_unlock(&globus_l_xio_load_lock);
    
    *out_driver = GLOBUS_NULL;
    GlobusXIODebugExitWithError();
    return result;
}

globus_result_t
globus_xio_driver_unload(
    globus_xio_driver_t                 driver)
{
    globus_xio_driver_hook_t *          hook;
    globus_result_t                     result;
    GlobusXIOName(globus_xio_driver_unload);
    
    GlobusXIODebugEnter();
    /** 
     * XXX need to remove entry after last driver unloaded for dll entries
     * 
     * builtins would always exist.  need a flag to indicate this
     */
    globus_rmutex_lock(&globus_l_xio_load_lock);
    {
        hook = (globus_xio_driver_hook_t *) globus_hashtable_lookup(
            &globus_l_xio_load_drivers, 
            (void *) driver->name);
        if(!hook)
        {
            /* not loaded yet */
            result = GlobusXIOErrorInvalidDriver("Driver not loaded");
            goto error_hook;
        }

        globus_i_xio_close_handles(driver);
        hook->unload(driver);
    
        if(--hook->ref_count == 0)
        {
            globus_module_deactivate(hook->module);
            /* this is where i would unload dll and remove from table */
        }
        
        globus_module_deactivate(GLOBUS_XIO_MODULE);
    }
    globus_rmutex_unlock(&globus_l_xio_load_lock);
    
    GlobusXIODebugExit();
    return GLOBUS_SUCCESS;

error_hook:
    globus_rmutex_unlock(&globus_l_xio_load_lock);
    
    GlobusXIODebugExitWithError();
    return result;
}

globus_bool_t
globus_xio_driver_error_match(
    globus_xio_driver_t                 driver,
    globus_object_t *                   error,
    int                                 type)
{
    globus_xio_driver_hook_t *          hook;
    globus_bool_t                       rc;
    GlobusXIOName(globus_xio_driver_error_match);
    
    globus_rmutex_lock(&globus_l_xio_load_lock);
    {
        hook = (globus_xio_driver_hook_t *) globus_hashtable_lookup(
            &globus_l_xio_load_drivers, 
            (void *) driver->name);
        if(hook)
        {
            rc = globus_error_match(error, hook->module, type);
        }
        else
        {
            rc = GLOBUS_FALSE;
        }
    }
    globus_rmutex_unlock(&globus_l_xio_load_lock);
    
    return rc;
}
