#include "globus_xio_load.h"
#include "globus_i_xio.h"

#define GLOBUS_L_XIO_DRIVER_TABLE_SIZE 16

extern globus_xio_driver_hook_t         @XIO_BUILTIN_HOOKS_DEC@;

static globus_xio_driver_hook_t *       builtins[] = 
{
    @XIO_BUILTIN_HOOKS_DEF@, GLOBUS_NULL
};

static globus_hashtable_t               globus_l_xio_load_drivers;
static globus_mutex_t                   globus_l_xio_load_lock;

int
globus_i_xio_load_init(void)
{
    globus_xio_driver_hook_t **         builtin;
    
    globus_mutex_init(&globus_l_xio_load_lock, GLOBUS_NULL);
    
    if(globus_hashtable_init(
        &globus_l_xio_load_drivers,
        GLOBUS_L_XIO_DRIVER_TABLE_SIZE,
        globus_hashtable_string_hash,
        globus_hashtable_string_keyeq) != GLOBUS_SUCCESS)
    {
        return -1;
    }
    
    builtin = builtins;
    while(*builtin)
    {
        globus_hashtable_insert(
            &globus_l_xio_load_drivers, 
            (void *) (*builtin)->name, 
            *builtin);
            
        builtin++;
    }
    
    return GLOBUS_SUCCESS;
}

static
void
globus_l_xio_load_destroy_cb(
    void *                              arg)
{
    globus_xio_driver_hook_t *          hook;
    
    hook = (globus_xio_driver_hook_t *) arg;
    if(hook->ref_count > 0)
    {
        hook->ref_count = 0;
        globus_module_deactivate(hook->module);
    }
}

int
globus_i_xio_load_destroy(void)
{
    globus_mutex_destroy(&globus_l_xio_load_lock);
    globus_hashtable_destroy_all(
        &globus_l_xio_load_drivers, globus_l_xio_load_destroy_cb);

    return GLOBUS_SUCCESS;
}

globus_result_t
globus_xio_driver_load(
    const char *                        driver_name,
    globus_xio_driver_t *               out_driver,
    ...)
{
    globus_xio_driver_hook_t *          hook;
    globus_result_t                     result;
    va_list                             ap;
    GlobusXIOName(globus_xio_driver_load);
    
    result = GLOBUS_SUCCESS;
    globus_mutex_lock(&globus_l_xio_load_lock);
    {
        hook = (globus_xio_driver_hook_t *) globus_hashtable_lookup(
            &globus_l_xio_load_drivers, 
            (void *) driver_name);
    
        if(!hook)
        {
            /* not a builtin or not loaded yet... here is where I would do the 
             * dll stuff
             */
            
            result = GlobusXIOErrorInvalidDriver("Could not find driver");
        }
        else
        {
            if(++hook->ref_count == 1)
            {
                if(globus_module_activate(hook->module) != GLOBUS_SUCCESS)
                {
                    hook->ref_count--;
                    result = GlobusXIOErrorInvalidDriver("Deactivate failed");
                }
            }
        }
    }
    globus_mutex_unlock(&globus_l_xio_load_lock);
    
    if(result != GLOBUS_SUCCESS)
    {
        goto error_load;
    }
    
    va_start(ap, out_driver);
    result = hook->load(out_driver, ap);
    va_end(ap);
    
    if(result != GLOBUS_SUCCESS)
    {
        result = GlobusXIOErrorWrapFailed("globus_xio_driver_init_t", result);
        goto error_init;
    }
    
    return GLOBUS_SUCCESS;

error_init:
    if(--hook->ref_count == 0)
    {
        globus_module_deactivate(hook->module);
    }
    
error_load:
    *out_driver = GLOBUS_NULL;
    return result;
}

globus_result_t
globus_xio_driver_unload(
    globus_xio_driver_t                 driver)
{
    globus_xio_driver_hook_t *          hook;
    globus_result_t                     result;
    GlobusXIOName(globus_xio_driver_unload);
    
    /** 
     * XXX need to remove entry after last driver unloaded... probably need a
     * reference counted container (or maybe, dll_unload will tell me?)
     * 
     * builtins would always exist.  if i do ref count, they start with 1
     */
    globus_mutex_lock(&globus_l_xio_load_lock);
    {
        hook = (globus_xio_driver_hook_t *) globus_hashtable_lookup(
            &globus_l_xio_load_drivers, 
            (void *) driver->name);
    }
    globus_mutex_unlock(&globus_l_xio_load_lock);
    
    if(!hook)
    {
        /* not loaded yet */
        
        result = GlobusXIOErrorInvalidDriver("Driver not loaded");
        goto error_hook;
    }
    
    hook->unload(driver);
    
    globus_mutex_lock(&globus_l_xio_load_lock);
    {
        if(--hook->ref_count == 0)
        {
            globus_module_deactivate(hook->module);
        }
    }
    globus_mutex_unlock(&globus_l_xio_load_lock);
    
    return GLOBUS_SUCCESS;

error_hook:
    return result;
}

globus_bool_t
globus_xio_driver_error_match(
    globus_xio_driver_t                 driver,
    globus_object_t *                   error,
    int                                 type)
{
    globus_xio_driver_hook_t *          hook;
    GlobusXIOName(globus_xio_driver_error_match);
    
    globus_mutex_lock(&globus_l_xio_load_lock);
    {
        hook = (globus_xio_driver_hook_t *) globus_hashtable_lookup(
            &globus_l_xio_load_drivers, 
            (void *) driver->name);
    }
    globus_mutex_unlock(&globus_l_xio_load_lock);
    
    if(hook)
    {
        return globus_error_match(error, hook->module, type);
    }
    else
    {
        return GLOBUS_FALSE;
    }
}
